# -*- coding: utf-8 -*-
"""Robot navigation problem_HitarthVachhani.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qd-QA_FvogV9GEiA924PeH3rirWn_OPM
"""

import numpy as np
import heapq
import random
import matplotlib.pyplot as plt

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def astar(maze, start, end):
    movements = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    def is_valid_move(x, y):
        return 0 <= x < maze.shape[0] and 0 <= y < maze.shape[1] and maze[x, y] == 0
    open_set = []
    heapq.heappush(open_set, (heuristic(start, end), 0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, end)}
    while open_set:
        _, current_g, current = heapq.heappop(open_set)
        if current == end:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
        for move in movements:
            neighbor = (current[0] + move[0], current[1] + move[1])
            if is_valid_move(*neighbor):
                tentative_g_score = current_g + 1
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, end)
                    heapq.heappush(open_set, (f_score[neighbor], tentative_g_score, neighbor))
    return None

while True:
    rows = random.randint(5, 10)
    cols = random.randint(5, 10)
    maze = np.random.choice([0, 1], size=(rows, cols), p=[0.7, 0.3])
    start = (0, 0)
    end = (rows - 1, cols - 1)
    maze[start] = 0
    maze[end] = 0
    path = astar(maze, start, end)
    if path:
        print(f"Maze size: {rows}x{cols}")
        print("Maze:\n", maze)
        print("Path found:", path)
        break

plt.figure(figsize=(6, 6))
plt.imshow(maze, cmap="binary")

for (x, y) in path:
    plt.gca().add_patch(plt.Rectangle((y - 0.5, x - 0.5), 1, 1, color="cyan", alpha=0.6))
plt.scatter(start[1], start[0], c="green", s=200, marker="o", label="Start")
plt.scatter(end[1], end[0], c="red", s=200, marker="X", label="End")
plt.legend()
plt.title("Random Maze with Path (A*)")
plt.gca().invert_yaxis()
plt.show()